## 题目1

总结几种 socket 粘包的解包方式: fix length/delimiter based/length field based frame decoder。尝试举例其应用

### MTU

指网络协议中的最大传输单元。可以通过ifconfig命令查看网卡的MTU。

### MSS

指TCP建立连接后双方约定的最大TCP报文长度。若底层的MTU长度为1500byte，MSS=1500-20(IP Header) - 20(TCP Header) = 1460 byte。

现象：

正常情况下一个TCP只会传送一个应用数据包，但是在发生粘包时，多个TCP数据包会通过一个TCO包传输。而拆包时，一个应用数据包可能会拆分成两段进行传输，另一段可能会和其他数据应用包粘合。

### 原因：

粘包：

-   要发送的数据小于TCP缓冲区的大小，TCP将多次写入缓冲区的数据一次性发送过去；
-   接收数据段的应用层没有及时读取缓冲区的数据；
-   数据发送过快，数据包堆积导致缓冲区积压多个数据后才一次性发送出去（如果客户端每发送一段数据就睡眠一段时间就不会发生粘包）。

拆包：

-   发送的应用数据包太大，超过MSS就会被拆分成多个TCP报文分开传输。

### 解决方案

通常的做法就是在发送的应用数据包前加个包头，包头长度一般为4字节，指明这个数据包的真实长度，每次在server读取的时候按照这个长度进行读取，对于服务端读取具体如下：

1.  每次读取到TCP数据包便将其和上次的TCP数据包拼接；
2.  若剩下的数据长度小于数据包头部长度，则出现拆包，继续读取下一个TCP数据包；
3.  再不出现拆包问题后，将数据包头部指定长度的数据读取出来；
4.  去掉已读取的数据，剩下的数据包继续读取。

还有一种解决方案，就是每次发送的应用数据包，根据具体情况可以指定特殊字符结尾来发送，在服务端接收的时候，读取数据以客户端指定结尾字符为结束读取。例如：若发送的全是汉字，则可以指定字母结尾：

```go
message := "这是一条完整数据a"			// 发送数据以a结尾
```

在接收数据时，读到字符`a`后就约定为读取完一条完整的数据，否则，接着读取下一条TCP数据包，知道读取到完整的应用数据包。

最后一种解决方案类似上一种：发送方和接收方都规定一个固定大小的缓冲区，当字符长度不够时则使用空字符串填补（不建议）。